/ { // This portion in the "root" of the device tree

    // A GNSS device connected to I2C1
    cfg-device-gnss {
        compatible = "u-blox,ubxlib-device-gnss";
        status = "okay";
        transport-type = "i2c1";
        // There is an I2C segment size limitation on some STM32
        // devices so limit to 255 byte segments to be on the safe
        // side
        i2c-max-segment-size = <255>;
        // Allow the GNSS module type to be determined automatically
    };

    chosen {
            // Only required if U_CFG_PPP_ENABLE is enabled
            zephyr,ppp-uart = &uart99;
    };

    // Only required if U_CFG_PPP_ENABLE is enabled
    // This creates instance 99 of a uart that we will give to zephyr,ppp-uart
    uart99: uart-ppp@8000 { // The "8000" here is irrelevant but required for Zephyr to work
        compatible = "u-blox,uart-ppp"; // The important part: this is an instance of u-blox,uart-ppp
        reg = <0x8000 0x100>; // This is irrelevant but required for Zephyr to work
        status = "okay"; // Zephyr boiler-plate
    };
};

// Enable DMA (a) because STM32 serial ports
// have only a one-byte buffer, so will lose
// characters without it, and, (b) because we
// need an asynchronous UART for PPP and the
// device tree configuration on STM32 won't
// allow that unless at least one thing has
// DMA enabled
// Guidance from table 136 of reference manual
// RM0456 and
// https://github.com/zephyrproject-rtos/zephyr/blob/main/dts/bindings/dma/st%2Cstm32u5-dma.yaml
// Also, make console logging use DMA for speed
&usart3 {
    dmas = <&gpdma1 0 29 STM32_DMA_PERIPH_TX
            &gpdma1 1 28 STM32_DMA_PERIPH_RX>;
    dma-names = "tx", "rx";
};
&gpdma1 {
    status = "okay";
};